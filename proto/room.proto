syntax = "proto3";

package marble.room;

service RoomService {
  // === Room management ===
  rpc CreateRoom(CreateRoomRequest) returns (CreateRoomResponse);       // Auth: Required (creator=host)
  rpc GetRoom(GetRoomRequest) returns (GetRoomResponse);               // Auth: Required
  rpc ListRooms(ListRoomsRequest) returns (ListRoomsResponse);         // Auth: Required
  rpc JoinRoom(JoinRoomRequest) returns (JoinRoomResponse);            // Auth: Required
  rpc GetRoomUsers(GetRoomUsersRequest) returns (GetRoomUsersResponse); // Auth: Required
  rpc KickPlayer(KickPlayerRequest) returns (KickPlayerResponse);      // Auth: Required (host only)

  // === Game lifecycle ===
  rpc StartGame(StartGameRequest) returns (StartGameResponse);         // Auth: Required (host only)
  rpc ReportArrival(ReportArrivalRequest) returns (ReportArrivalResponse); // Auth: Required (host only)

  // === P2P topology ===
  rpc RegisterPeerId(RegisterPeerIdRequest) returns (RegisterPeerIdResponse);     // Auth: Required (member)
  rpc ReportConnection(ReportConnectionRequest) returns (ReportConnectionResponse); // Auth: Required (member)
  rpc GetTopology(GetTopologyRequest) returns (GetTopologyResponse);               // Auth: Required (member)
  rpc GetRoomTopology(GetRoomTopologyRequest) returns (GetRoomTopologyResponse);   // Auth: Required (member)
  rpc ResolvePeerIds(ResolvePeerIdsRequest) returns (ResolvePeerIdsResponse);     // Auth: Required (member)
}

// State machine: WAITING -> PLAYING -> ENDED
enum RoomState {
  ROOM_STATE_UNSPECIFIED = 0;
  ROOM_STATE_WAITING = 1;   // Players can join
  ROOM_STATE_PLAYING = 2;   // Game in progress (marbles spawned)
  ROOM_STATE_ENDED = 3;     // All players arrived or timeout
}

// Room role (enum for extensibility instead of bool)
enum RoomRole {
  ROOM_ROLE_UNSPECIFIED = 0;  // Server auto-infer
  ROOM_ROLE_PARTICIPANT = 1;  // Game participant
  ROOM_ROLE_SPECTATOR = 2;   // Spectator
}

// --- Room management ---

message CreateRoomRequest {
  string map_id = 1;         // MapService map_id
  uint32 max_players = 2;    // 2-32
  string room_name = 3;      // Optional (empty = server auto-generate)
  bool is_public = 4;        // Whether to expose in ListRooms (default true)
}
message CreateRoomResponse {
  RoomInfo room = 1;
  PeerTopology topology = 2;  // Host's initial topology (includes signaling_url)
}

message GetRoomRequest { string room_id = 1; }
message GetRoomResponse { RoomInfo room = 1; }

message ListRoomsRequest {
  uint32 page_size = 1;             // 1-100, default 20
  string page_token = 2;
  repeated RoomState states = 3;    // Filter: specific states only (empty = all)
  string map_id = 4;                // Filter: specific map
  string name_query = 5;            // Filter: name search
  bool has_available_slots = 6;     // Filter: rooms with free slots only
}
message ListRoomsResponse {
  repeated RoomSummary rooms = 1;
  string next_page_token = 2;
  uint32 total_count = 3;
}

message JoinRoomRequest {
  string room_id = 1;
  optional RoomRole role = 2; // Unspecified = server auto-infer (participants < max_players -> PARTICIPANT, else SPECTATOR)
}
message JoinRoomResponse {
  RoomInfo room = 1;
  PeerTopology topology = 2;  // Topology (includes signaling_url)
}

message GetRoomUsersRequest { string room_id = 1; }
message GetRoomUsersResponse { repeated RoomUser users = 1; }

message RoomUser {
  string user_id = 1;     // Use UserService.GetUsers to resolve display_name
  bool is_host = 2;
  RoomRole role = 3;      // PARTICIPANT or SPECTATOR
  string joined_at = 4;   // RFC 3339
}

message KickPlayerRequest {
  string room_id = 1;
  string target_user_id = 2;
}
message KickPlayerResponse {
  RoomInfo room = 1;
}

// --- Game lifecycle ---

message StartGameRequest {
  string room_id = 1;
  uint64 start_frame = 2;   // Marble spawn frame (rng_seed already issued at room creation)
}
message StartGameResponse {
  RoomInfo room = 1;
}

message ReportArrivalRequest {
  string room_id = 1;
  string arrived_user_id = 2;
  uint64 arrival_frame = 3;
  uint32 rank = 4;
}
message ReportArrivalResponse {
  RoomInfo room = 1;
}

// --- Room info ---

message RoomInfo {
  string room_id = 1;
  string room_name = 2;
  string map_id = 3;           // Use MapService.GetMap for map data
  string host_user_id = 4;     // Use UserService.GetUser for host name
  uint32 max_players = 5;
  uint32 current_players = 6;
  RoomState state = 7;
  bool is_public = 8;
  string created_at = 9;
  string started_at = 10;      // Empty if WAITING
  NetworkConfig network_config = 11;
  GameState game_state = 12;   // rng_seed set at creation, rest filled after StartGame
  uint64 topology_version = 13; // Monotonically increasing counter on topology changes
}

message RoomSummary {
  string room_id = 1;
  string room_name = 2;
  string map_id = 3;
  string host_user_id = 4;
  uint32 max_players = 5;
  uint32 current_players = 6;
  RoomState state = 7;
  string created_at = 8;
}

message NetworkConfig {
  uint32 lockstep_delay_frames = 1;
  uint32 gossip_ttl = 2;
  uint32 mesh_group_size = 3;
  uint32 peer_connections = 4;
}

message GameState {
  uint64 rng_seed = 1;              // Server auto-generates at room creation (immediate lobby physics use)
  uint64 start_frame = 2;           // Set at StartGame
  repeated PlayerResult results = 3; // Sorted by rank
}

message PlayerResult {
  string user_id = 1;
  uint32 rank = 2;
  uint64 arrival_frame = 3;
}

// --- P2P topology (player_id -> user_id unified) ---

message PeerConnection {
  string peer_id = 1;
  string user_id = 2;
}

message PeerTopology {
  string signaling_url = 1;   // matchbox signaling WebSocket URL (recoverable via GetTopology after refresh)
  uint32 mesh_group = 2;
  bool is_bridge = 3;
  repeated PeerConnection connect_to = 4;
  repeated PeerConnection bridge_peers = 5;
}

message PeerConnectionStatus {
  string peer_id = 1;
  uint32 rtt_ms = 2;
  float packet_loss = 3;
  bool connected = 4;
}

message RegisterPeerIdRequest {
  string room_id = 1;
  string peer_id = 2;
}
message RegisterPeerIdResponse {
  optional PeerTopology updated_topology = 1;
}

message ReportConnectionRequest {
  string room_id = 1;
  repeated PeerConnectionStatus peer_statuses = 2;
}
message ReportConnectionResponse {
  bool topology_changed = 1;
  optional PeerTopology new_topology = 2;
}

message GetTopologyRequest { string room_id = 1; }
message GetTopologyResponse { PeerTopology topology = 1; }

message GetRoomTopologyRequest { string room_id = 1; }
message GetRoomTopologyResponse { repeated PlayerTopologyInfo players = 1; }

message PlayerTopologyInfo {
  string user_id = 1;
  PeerTopology topology = 2;
  bool is_connected = 3;
}

message ResolvePeerIdsRequest {
  string room_id = 1;
  repeated string peer_ids = 2;
}
message ResolvePeerIdsResponse {
  map<string, string> peer_to_user = 1;  // peer_id -> user_id
}
